<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>BCR Visualizer</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.5);
    --accent: #ff6b6b;
    --ui-color: #fff;
    --ui-border: rgba(255,255,255,0.06);
    --player-height: 48px;
    --player-bg: rgba(0,0,0,0.45);
    --loading-color: #fff;
  }
  html,body{
    height:100%;
    margin:0;
    background:#000;
    overflow:hidden;
    font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }
  canvas{
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    display:block;
    touch-action:none;
  }
  #ui, #ui-toggle{
    position:fixed;
    z-index:9999;
    background:var(--ui-bg);
    color:var(--ui-color);
    padding:12px;
    border-radius:12px;
    backdrop-filter:blur(6px);
    font-size:14px;
    transition: transform 0.3s ease-out, opacity 0.3s ease-out;
  }
  #ui{
    left:12px;
    top:12px;
    min-width:220px;
  }
  #ui.hidden{
    transform: translateX(-110%);
    opacity: 0;
    pointer-events: none;
  }
  #ui-toggle{
    left: auto;
    right: 12px;
    top: 12px;
    background: var(--ui-bg);
    border: none;
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 8px;
    font-weight: 600;
    color: var(--ui-color);
    backdrop-filter: blur(6px);
  }
  #ui .row{
    display:flex;
    gap:8px;
    align-items:center;
  }
  #ui label{
    display:block;
    margin-top:8px;
    font-size:13px;
  }
  input[type=range]{
    width:100%;
    -webkit-appearance: none;
    height: 6px;
    background: #555;
    border-radius: 3px;
    outline: none;
  }
  input[type=range]::-webkit-slider-thumb{
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 4px rgba(0,0,0,0.4);
  }
  button{
    background:var(--accent);
    border:0;
    color:#fff;
    padding:8px 12px;
    border-radius:8px;
    font-weight:600;
    cursor:pointer;
    transition: background-color 0.2s;
  }
  button:hover{
    background: #ff4747;
  }
  button:disabled{
    background:#444;
    cursor: not-allowed;
  }
  #small{
    font-size:12px;
    color:#ddd;
    margin-top:8px;
  }

  /* Redesigned and centered audio control panel */
  #audioControl{
    position:fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom:12px;
    z-index:9998;
    background:var(--player-bg);
    backdrop-filter: blur(6px);
    border: 2px solid var(--ui-border);
    border-radius: 12px;
    padding: 12px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    color: var(--ui-color);
    width: calc(100% - 24px);
    max-width: 480px;
  }

  #audioControl button{
    background: none;
    border: none;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }

  #audioControl button svg{
    width: 24px;
    height: 24px;
    fill: #fff;
  }

  #audioControl .progress-bar-container{
    flex-grow: 1;
    position: relative;
    height: 6px;
    background: #555;
    border-radius: 3px;
    cursor: pointer;
  }
  #audioControl .progress-bar{
    height: 100%;
    width: 0%;
    background: var(--accent);
    border-radius: 3px;
    transition: width 0.1s linear;
  }
  #audioControl .time-display{
    font-size: 12px;
    white-space: nowrap;
  }

  #playOverlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9997;
    pointer-events:auto;
  }
  #playBtn{
    background:var(--player-bg);
    border:2px solid var(--ui-border);
    backdrop-filter:blur(6px);
    padding:20px;
    border-radius:999px;
    display:flex;
    align-items:center;
    gap:10px;
    cursor:pointer;
    transition: transform 0.2s ease-out;
  }
  #playBtn:hover{
    transform: scale(1.05);
  }
  #playBtn svg{
    width:42px;
    height:42px;
  }

</style>
</head>
<body>
  <div id="ui">
    <div class="row">
      <button id="preview">Play</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <label>Symmetry (segments) <span id="symVal">3</span>
      <input id="sym" type="range" min="1" max="12" step="1" value="3">
    </label>
    <label>Ink Density <span id="densVal">0.08</span>
      <input id="density" type="range" min="0" max="1" step="0.01" value="0.08">
    </label>
    <label>Speed <span id="spdVal">0.80</span>
      <input id="speed" type="range" min="0" max="2" step="0.01" value="0.80">
    </label>
    <label>Warmth Bias <span id="warmVal">0.8</span>
      <input id="warmth" type="range" min="0" max="1" step="0.01" value="0.8">
    </label>
    <label>Brightness <span id="brightVal">0.83</span>
      <input id="bright" type="range" min="0.2" max="1" step="0.01" value="0.83">
    </label>
  </div>

  <button id="ui-toggle">Hide Controls</button>

  <canvas id="c"></canvas>
  <div id="audioControl">
    <button id="playPauseBtn">
      <svg id="playIcon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z" fill="#fff"/></svg>
      <svg id="pauseIcon" style="display:none;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" fill="#fff"/></svg>
    </button>
    <div class="time-display" id="currentTime">0:00</div>
    <div class="progress-bar-container" id="progressBarContainer">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="time-display" id="duration">0:00</div>
  </div>
  <div id="playOverlay"><div id="playBtn" aria-hidden="false" role="button">
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11" stroke="rgba(255,255,255,0.12)" stroke-width="1.5"/><path d="M10 8.5v7l5-3.5-5-3.5z" fill="#fff"/></svg>
    <div style="color:#fff;font-weight:700">Tap to Play</div>
  </div></div>

<script>
const AUTO_AUDIO_URL = 'https://ia800905.us.archive.org/1/items/bcr-3/BCR%203.wav';

// ---------- Utilities (Perlin noise) ----------
const Perlin = (function(){ const p = new Uint8Array(512); for(let i=0;i<256;i++) p[i]=i; for(let i=255;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [p[i],p[j]]=[p[j],p[i]]; } for(let i=0;i<512;i++) p[i+256]=p[i]; function fade(t){ return t*t*t*(t*(t*6-15)+10); } function lerp(a,b,t){ return a + t*(b-a); } function grad(hash,x,y){ const h=hash&3; const u = h<2?x:y; const v = h<2?y:x; return ((h&1)? -u:u) + ((h&2)? -2*v:2*v); } return { noise(x,y){ const X=Math.floor(x)&255, Y=Math.floor(y)&255; const xf=x-Math.floor(x), yf=y-Math.floor(y); const u=fade(xf), v=fade(yf); const aa=p[p[X]+Y], ab=p[p[X]+Y+1], ba=p[p[X+1]+Y], bb=p[p[X+1]+Y+1]; const x1=lerp(grad(aa, xf, yf), grad(ba, xf-1, yf), u); const x2=lerp(grad(ab, xf, yf-1), grad(bb, xf-1, yf-1), u); return (lerp(x1,x2,v)+1)*0.5; } }})();

// ---------- Canvas setup ----------
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d', { alpha:true });
function resize(){ const w=innerWidth, h=innerHeight, dpr = Math.max(1, devicePixelRatio||1); canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr); canvas.style.width = w+'px'; canvas.style.height = h+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);} addEventListener('resize',resize); resize();

// ---------- UI bindings ----------
const UI = {
  uiPanel: document.getElementById('ui'),
  uiToggle: document.getElementById('ui-toggle'),
  preview: document.getElementById('preview'),
  stop: document.getElementById('stop'),
  playPauseBtn: document.getElementById('playPauseBtn'),
  playIcon: document.getElementById('playIcon'),
  pauseIcon: document.getElementById('pauseIcon'),
  progressBarContainer: document.getElementById('progressBarContainer'),
  progressBar: document.getElementById('progressBar'),
  currentTime: document.getElementById('currentTime'),
  duration: document.getElementById('duration'),
  sym: document.getElementById('sym'),
  symVal: document.getElementById('symVal'),
  density: document.getElementById('density'),
  densVal: document.getElementById('densVal'),
  speed: document.getElementById('speed'),
  spdVal: document.getElementById('spdVal'),
  warmth: document.getElementById('warmth'),
  warmVal: document.getElementById('warmVal'),
  bright: document.getElementById('bright'),
  brightVal: document.getElementById('brightVal'),
};

UI.uiToggle.addEventListener('click', () => {
    UI.uiPanel.classList.toggle('hidden');
    UI.uiToggle.textContent = UI.uiPanel.classList.contains('hidden') ? 'Show Controls' : 'Hide Controls';
});

function bindRange(el,val){ el.addEventListener('input', ()=> val.textContent = el.value ); }
bindRange(UI.sym, UI.symVal); bindRange(UI.density, UI.densVal); bindRange(UI.speed, UI.spdVal); bindRange(UI.warmth, UI.warmVal); bindRange(UI.bright, UI.brightVal);

// ---------- Audio setup ----------
let audioEl=null, audioCtx=null, analyser=null, dataArray=null, sourceNode=null, bufferLength=1024;
let bassSmooth=0, bassEnv=0;

// Helper to format time
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
}

async function initAudioFromUrl(url){
  // tear down
  if (audioEl){ try{ audioEl.pause(); }catch(e){} audioEl.remove(); sourceNode && sourceNode.disconnect(); }
  audioEl = new Audio();
  audioEl.src = url;
  audioEl.crossOrigin = 'anonymous';
  audioEl.preload = 'auto';

  // Attach event listeners for the custom player
  audioEl.addEventListener('loadedmetadata', () => {
    UI.duration.textContent = formatTime(audioEl.duration);
  });
  audioEl.addEventListener('timeupdate', () => {
    const progress = (audioEl.currentTime / audioEl.duration) * 100;
    UI.progressBar.style.width = `${progress}%`;
    UI.currentTime.textContent = formatTime(audioEl.currentTime);
  });
  audioEl.addEventListener('play', () => {
    UI.playIcon.style.display = 'none';
    UI.pauseIcon.style.display = 'block';
    document.getElementById('playOverlay').style.display='none';
  });
  audioEl.addEventListener('pause', () => {
    UI.playIcon.style.display = 'block';
    UI.pauseIcon.style.display = 'none';
    document.getElementById('playOverlay').style.display='flex';
  });
  audioEl.onended = ()=>{
    UI.stop.disabled = true;
    UI.playIcon.style.display = 'block';
    UI.pauseIcon.style.display = 'none';
    document.getElementById('playOverlay').style.display='flex';
  };

  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048; // more resolution
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);

  sourceNode = audioCtx.createMediaElementSource(audioEl);
  sourceNode.connect(analyser);
  analyser.connect(audioCtx.destination);

  UI.stop.disabled = false;
}

// auto-init on load but DO NOT autoplay audio (browsers block sound without gesture). We'll preload and be ready.
initAudioFromUrl(AUTO_AUDIO_URL).catch(console.warn);

// Play / Stop
async function startAudio(){
  if (!audioEl) await initAudioFromUrl(AUTO_AUDIO_URL);
  if (audioCtx && audioCtx.state === 'suspended') try{ await audioCtx.resume(); }catch(e){}
  try{ await audioEl.play(); }catch(e){ console.warn('play blocked', e); }
}

function pauseAudio(){
  if(audioEl) audioEl.pause();
}

UI.preview.addEventListener('click', async ()=>{
  await startAudio();
  UI.stop.disabled = false;
  document.getElementById('playOverlay').style.display='none';
});

UI.stop.addEventListener('click', ()=>{
  if (audioEl){ audioEl.pause(); audioEl.currentTime = 0; UI.stop.disabled = true; document.getElementById('playOverlay').style.display='flex'; }
});

UI.playPauseBtn.addEventListener('click', async () => {
  if (audioEl.paused) {
    await startAudio();
    UI.stop.disabled = false;
  } else {
    pauseAudio();
  }
});

UI.progressBarContainer.addEventListener('click', (e) => {
  const rect = UI.progressBarContainer.getBoundingClientRect();
  const clickPosition = e.clientX - rect.left;
  const newTime = (clickPosition / rect.width) * audioEl.duration;
  if (!isNaN(newTime)) {
    audioEl.currentTime = newTime;
  }
});

// also overlay tap
document.getElementById('playOverlay').addEventListener('click', async ()=>{ await startAudio(); });
canvas.addEventListener('pointerdown', async ()=>{ if (!audioEl) await initAudioFromUrl(AUTO_AUDIO_URL); if (audioEl.paused) await startAudio(); else audioEl.pause(); });


// ---------- Helpers ----------
function hslToCss(h,s,l,a=1){ return `hsla(${h},${s}%,${l}%,${a})`; }
function mix(a,b,t){ return a + (b-a)*t; }
function paletteFor(t){ const warm=[15,30,50], cool=[230,280,160]; const res=[]; for(let i=0;i<warm.length;i++) res.push(mix(warm[i], cool[i], t)); return res; }

// ---------- Visual core (bass-focused) ----------
const inkCanvas = document.createElement('canvas'), inkCtx = inkCanvas.getContext('2d', { alpha:true });
function ensureInk(){ const w=innerWidth, h=innerHeight, dpr=Math.max(1, devicePixelRatio||1); inkCanvas.width = Math.floor(w*dpr); inkCanvas.height = Math.floor(h*dpr); inkCanvas.style.width = w+'px'; inkCanvas.style.height = h+'px'; inkCtx.setTransform(dpr,0,0,dpr,0,0); }
ensureInk(); addEventListener('resize', ensureInk);

let lastTime = performance.now();
function getAudioBands(arr){ if (!arr) return {bass:0,mids:0,highs:0,energy:0}; const n=arr.length; const bassEnd = Math.max(4, Math.floor(n * 0.08)); const midEnd = Math.floor(n * 0.45); let bass=0,mids=0,highs=0,tot=0; for(let i=0;i<n;i++){ tot += arr[i]; if (i < bassEnd) bass += arr[i] * (1 + (bassEnd - i)/bassEnd * 0.5); else if (i < midEnd) mids += arr[i]; else highs += arr[i]; } const denom = (tot||1); return { bass: (bass/(bassEnd))/255, mids:(mids/(midEnd-bassEnd))/255, highs:(highs/(n-midEnd))/255, energy: tot/(n*255) } }

// simple beat/peak detector on bass for stronger pump
let beatHold=0; function processBeat(bass){ // smooth envelope
  const attack = 0.3, release=0.12; if (bass > bassEnv) bassEnv += (bass - bassEnv) * attack; else bassEnv += (bass - bassEnv) * release; // detect quick peaks
  const isBeat = (bass > 0.22 && bass - bassSmooth > 0.06) || (bassEnv > 0.28);
  // decay smooth
  bassSmooth = bassSmooth * 0.88 + bass * 0.12;
  if (isBeat && beatHold <= 0){ beatHold = 6; return true; } beatHold = Math.max(0, beatHold-1); return false; }

function draw(now){ const s = parseFloat(UI.speed.value); const density = parseFloat(UI.density.value); const symmetry = Math.max(1, parseInt(UI.sym.value)); const warmthBias = parseFloat(UI.warmth.value); const bright = parseFloat(UI.bright.value);
  const dt = (now - lastTime) * 0.001 * s; const time = now * 0.001;
  lastTime = now;

  // read audio
  let spectrum = null; if (analyser && dataArray){ analyser.getByteFrequencyData(dataArray); spectrum = dataArray; }
  const bands = getAudioBands(spectrum);
  // stronger bass influence
  const bassInfluence = Math.min(2.5, bands.bass * 2.8 + bands.energy * 0.8);
  const highInfluence = Math.min(1.8, bands.highs * 1.6 + bands.mids * 0.4);
  const energy = bands.energy;

  const beat = processBeat(bands.bass);

  // background
  const blend = (Math.sin(time*0.02) * 0.5 + 0.5) * (1 - warmthBias) + warmthBias * (1 - (Math.sin(time*0.01)*0.5+0.5));
  const pal = paletteFor(blend);
  const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
  g.addColorStop(0, hslToCss(pal[0], 60, 10, 1 * bright));
  g.addColorStop(0.5, hslToCss(pal[1], 55, 8, 1 * bright));
  g.addColorStop(1, hslToCss(pal[2], 50, 9, 1 * bright));
  ctx.globalCompositeOperation='source-over'; ctx.fillStyle=g; ctx.fillRect(0,0,innerWidth,innerHeight);

  // ink feedback fade
  inkCtx.globalCompositeOperation='destination-out'; inkCtx.fillStyle = `rgba(0,0,0,${0.03 * (1/density)})`; inkCtx.fillRect(0,0,innerWidth,innerHeight); inkCtx.globalCompositeOperation='lighter';

  const centerX = innerWidth/2, centerY = innerHeight/2;
  // Reduced max radius for smaller overall shapes
  const maxR = Math.min(innerWidth, innerHeight) * 0.35;
  const blobs = Math.max(3, Math.floor(6 * density));

  for (let b=0;b<blobs;b++){
    const baseAngle = (time * (0.4 + b*0.02) + b * 2.3);
    const angle = baseAngle + Math.sin(time * (0.7 + b*0.05)) * 1.2;
    // stronger beat-driven radius modulation
    const radialPulse = 1 + bassInfluence * (0.9 + 0.6 * Math.sin(time*2.7 + b));
    const r = maxR * (0.15 + 0.6 * Math.abs(Math.sin(b * 1.1234 + time * (0.14 + b*0.02))));
    const px = centerX + Math.cos(angle) * (r * radialPulse * 0.8);
    const py = centerY + Math.sin(angle) * (r * radialPulse * 0.8);

    const pb = (b / blobs);
    const hue = mix(pal[0], pal[1], pb*0.6 + energy*0.4);
    const hue2 = mix(pal[1], pal[2], pb*0.5 + bands.mids*0.4);
    const sat = Math.floor(55 + energy*35 + bassInfluence*10);
    const light = Math.floor(36 + energy*36 + bassInfluence*8);
    inkCtx.fillStyle = hslToCss(mix(hue,hue2,0.5), sat, light, 0.18 * Math.min(1, 0.6 + density + bassInfluence*0.12));

    inkCtx.beginPath();
    const steps = 28 + Math.floor(28 * (1 - density));
    for (let i=0;i<=steps;i++){
      const theta = (i / steps) * Math.PI*2;
      const nx = Math.cos(theta) * (0.5 + pb*0.2) + time*0.06;
      const ny = Math.sin(theta) * (0.5 + pb*0.2) - time*0.03;
      const n = Perlin.noise(nx * (1+pb*3) + b, ny*(1+pb*2) - b*0.2);
      // Reduced displacement for smaller, more contained shapes
      const disp = (n - 0.5) * (20 + 80 * (1-pb)) * (0.8 + highInfluence) * (0.9 + bassInfluence*0.25);
      const rr = r * (0.25 + pb*0.75) * (0.6 + 0.45 * radialPulse) + disp;
      const vx = px + Math.cos(theta) * rr;
      const vy = py + Math.sin(theta) * rr;
      if (i===0) inkCtx.moveTo(vx, vy); else inkCtx.lineTo(vx, vy);
    }
    inkCtx.closePath(); inkCtx.fill();

    inkCtx.strokeStyle = hslToCss(mix(hue,hue2,0.4), 60, Math.min(70, light+10), 0.06 + energy*0.06 + bassInfluence*0.03); inkCtx.lineWidth = 1; inkCtx.stroke();

    // If we detect a beat, paint an extra burst
    if (beat){ inkCtx.beginPath(); inkCtx.arc(px, py, Math.max(6, 20 * (0.6 + bassInfluence)), 0, Math.PI*2); inkCtx.closePath(); inkCtx.fillStyle = hslToCss(hue, 70, 55, 0.08 + Math.min(0.4, bassInfluence*0.18)); inkCtx.fill(); }
  }

  // composite ink onto main canvas with symmetry
  ctx.save(); ctx.translate(centerX, centerY);
  const rot = time * 0.08 * (0.6 + 0.8 * (1 - parseFloat(UI.speed.value)));
  ctx.rotate(rot); ctx.globalCompositeOperation = 'lighter';
  const seg = symmetry;
  for (let m=0;m<seg;m++){
    ctx.save(); ctx.rotate((m/seg) * Math.PI*2);
    ctx.drawImage(inkCanvas, -centerX, -centerY, innerWidth, innerHeight);
    ctx.scale(-1,1); ctx.drawImage(inkCanvas, -centerX, -centerY, innerWidth, innerHeight);
    ctx.restore();
  }
  ctx.restore();

  // vignette
  ctx.globalCompositeOperation='source-over'; const vg = ctx.createRadialGradient(centerX, centerY, maxR*0.3, centerX, centerY, maxR*1.1);
  vg.addColorStop(0, `rgba(255,255,255,${0.02 * bright})`); vg.addColorStop(0.6, `rgba(0,0,0,0)`); vg.addColorStop(1, `rgba(0,0,0,${0.25 * (1/bright)})`);
  ctx.fillStyle = vg; ctx.fillRect(0,0,innerWidth,innerHeight);

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body>
</html>
